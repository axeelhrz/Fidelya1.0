import { supabase } from '@/lib/supabase/client'
import { createSupabaseServiceClient } from '@/lib/supabase/client'
import { Order, OrderItem, OrderWithDetails, OrderFilters, CreateOrderInput } from '@/types'
import { format } from 'date-fns'

export class OrderService {
  private static serviceClient = createSupabaseServiceClient()

  // Create a new order
  static async createOrder(orderData: {
    student_id: string
    delivery_date: string
    products: { product_id: string; quantity: number }[]
    notes?: string
  }) {
    const { student_id, delivery_date, products, notes } = orderData

    // Get guardian from current user
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) {
      throw new Error('Usuario no autenticado')
    }

    const { data: guardian } = await supabase
      .from('guardians')
      .select('id')
      .eq('user_id', user.id)
      .single()

    if (!guardian) {
      throw new Error('Guardian no encontrado')
    }

    // Validate student belongs to guardian
    const { data: student } = await supabase
      .from('students')
      .select('id')
      .eq('id', student_id)
      .eq('guardian_id', guardian.id)
      .single()

    if (!student) {
      throw new Error('Estudiante no encontrado o no pertenece al guardian')
    }

    // Get product details and calculate total
    const productIds = products.map(p => p.product_id)
    const { data: productDetails } = await supabase
      .from('products')
      .select('*')
      .in('id', productIds)
      .eq('available_date', delivery_date)
      .eq('is_active', true)

    if (!productDetails || productDetails.length !== productIds.length) {
      throw new Error('Algunos productos no están disponibles para la fecha seleccionada')
    }

    // Calculate total amount
    let totalAmount = 0
    const orderItems = products.map(({ product_id, quantity }) => {
      const product = productDetails.find(p => p.id === product_id)
      if (!product) {
        throw new Error(`Producto ${product_id} no encontrado`)
      }
      
      const unitPrice = product.price_student
      const subtotal = unitPrice * quantity
      totalAmount += subtotal

      return {
        product_id,
        quantity,
        unit_price: unitPrice,
        subtotal,
      }
    })

    // Create order
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .insert({
        guardian_id: guardian.id,
        student_id,
        delivery_date,
        day_of_week: format(new Date(delivery_date), 'EEEE'),
        total_amount: totalAmount,
        notes,
        order_number: '', // Will be generated by trigger
      })
      .select()
      .single()

    if (orderError) {
      throw new Error(`Error creando pedido: ${orderError.message}`)
    }

    // Create order items
    const orderItemsWithOrderId = orderItems.map(item => ({
      ...item,
      order_id: order.id,
    }))

    const { error: itemsError } = await supabase
      .from('order_items')
      .insert(orderItemsWithOrderId)

    if (itemsError) {
      // Rollback order creation
      await supabase.from('orders').delete().eq('id', order.id)
      throw new Error(`Error creando items del pedido: ${itemsError.message}`)
    }

    return order
  }

  // Get orders for current user
  static async getUserOrders(filters?: OrderFilters) {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) {
      throw new Error('Usuario no autenticado')
    }

    const { data: guardian } = await supabase
      .from('guardians')
      .select('id')
      .eq('user_id', user.id)
      .single()

    if (!guardian) {
      throw new Error('Guardian no encontrado')
    }

    let query = supabase
      .from('orders')
      .select(`
        *,
        student:students(*),
        order_items(
          *,
          product:products(*)
        ),
        payment:payments(*)
      `)
      .eq('guardian_id', guardian.id)

    // Apply filters
    if (filters?.date_from) {
      query = query.gte('delivery_date', filters.date_from)
    }
    if (filters?.date_to) {
      query = query.lte('delivery_date', filters.date_to)
    }
    if (filters?.status) {
      query = query.eq('status', filters.status)
    }
    if (filters?.student_id) {
      query = query.eq('student_id', filters.student_id)
    }

    query = query.order('created_at', { ascending: false })

    const { data, error } = await query

    if (error) {
      throw new Error(`Error obteniendo pedidos: ${error.message}`)
    }

    return data as OrderWithDetails[]
  }

  // Get order by ID
  static async getOrderById(orderId: string): Promise<OrderWithDetails> {
    const { data, error } = await supabase
      .from('orders')
      .select(`
        *,
        student:students(*),
        guardian:guardians(*),
        order_items(
          *,
          product:products(*)
        ),
        payment:payments(*)
      `)
      .eq('id', orderId)
      .single()

    if (error) {
      throw new Error(`Error obteniendo pedido: ${error.message}`)
    }

    return data as OrderWithDetails
  }

  // Update order status
  static async updateOrderStatus(orderId: string, status: Order['status']) {
    const { data, error } = await this.serviceClient
      .from('orders')
      .update({ status })
      .eq('id', orderId)
      .select()
      .single()

    if (error) {
      throw new Error(`Error actualizando estado del pedido: ${error.message}`)
    }

    return data
  }

  // Cancel order (only if pending)
  static async cancelOrder(orderId: string) {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) {
      throw new Error('Usuario no autenticado')
    }

    const { data: guardian } = await supabase
      .from('guardians')
      .select('id')
      .eq('user_id', user.id)
      .single()

    if (!guardian) {
      throw new Error('Guardian no encontrado')
    }

    // Check if order belongs to user and is pending
    const { data: order } = await supabase
      .from('orders')
      .select('status')
      .eq('id', orderId)
      .eq('guardian_id', guardian.id)
      .single()

    if (!order) {
      throw new Error('Pedido no encontrado')
    }

    if (order.status !== 'pending') {
      throw new Error('Solo se pueden cancelar pedidos pendientes')
    }

    const { data, error } = await supabase
      .from('orders')
      .update({ status: 'cancelled' })
      .eq('id', orderId)
      .select()
      .single()

    if (error) {
      throw new Error(`Error cancelando pedido: ${error.message}`)
    }

    return data
  }

  // Admin functions
  static async getAllOrders(filters?: OrderFilters) {
    let query = this.serviceClient
      .from('orders')
      .select(`
        *,
        student:students(*),
        guardian:guardians(*),
        order_items(
          *,
          product:products(*)
        ),
        payment:payments(*)
      `)

    // Apply filters
    if (filters?.date_from) {
      query = query.gte('delivery_date', filters.date_from)
    }
    if (filters?.date_to) {
      query = query.lte('delivery_date', filters.date_to)
    }
    if (filters?.status) {
      query = query.eq('status', filters.status)
    }
    if (filters?.student_id) {
      query = query.eq('student_id', filters.student_id)
    }
    if (filters?.guardian_id) {
      query = query.eq('guardian_id', filters.guardian_id)
    }

    query = query.order('created_at', { ascending: false })

    const { data, error } = await query

    if (error) {
      throw new Error(`Error obteniendo todos los pedidos: ${error.message}`)
    }

    return data as OrderWithDetails[]
  }

  // Get dashboard statistics
  static async getDashboardStats(date?: string) {
    const targetDate = date || format(new Date(), 'yyyy-MM-dd')

    const { data, error } = await this.serviceClient
      .rpc('get_orders_summary', { summary_date: targetDate })

    if (error) {
      throw new Error(`Error obteniendo estadísticas: ${error.message}`)
    }

    return data[0] || {
      total_orders: 0,
      total_amount: 0,
      pending_orders: 0,
      paid_orders: 0,
      orders_by_grade: {},
    }
  }

  // Get kitchen report
  static async getKitchenReport(date?: string) {
    const targetDate = date || format(new Date(), 'yyyy-MM-dd')

    const { data, error } = await this.serviceClient
      .rpc('get_kitchen_report', { report_date: targetDate })

    if (error) {
      throw new Error(`Error obteniendo reporte de cocina: ${error.message}`)
    }

    return data || []
  }

  // Utility functions
  static formatOrderNumber(orderNumber: string): string {
    return `#${orderNumber}`
  }

  static getOrderStatusLabel(status: Order['status']): string {
    const labels = {
      pending: 'Pendiente',
      paid: 'Pagado',
      cancelled: 'Cancelado',
      delivered: 'Entregado',
    }
    return labels[status] || status
  }

  static getOrderStatusColor(status: Order['status']): string {
    const colors = {
      pending: 'bg-yellow-100 text-yellow-800',
      paid: 'bg-green-100 text-green-800',
      cancelled: 'bg-red-100 text-red-800',
      delivered: 'bg-blue-100 text-blue-800',
    }
    return colors[status] || 'bg-gray-100 text-gray-800'
  }

  static calculateOrderTotal(orderItems: OrderItem[]): number {
    return orderItems.reduce((total, item) => total + item.subtotal, 0)
  }

  static formatPrice(priceInCents: number): string {
    return new Intl.NumberFormat('es-CL', {
      style: 'currency',
      currency: 'CLP',
    }).format(priceInCents / 100)
  }
}