import { 
  ClinicalAlert, 
  AlertFormData, 
  AlertType, 
  AlertTrigger,
  AlertActionLog,
  ALERT_TYPE_LABELS 
} from '@/types/alert';
import { FirestoreService } from './firestore';
import { WhatsAppService } from './whatsappService';
import { AIService } from './aiService';

export class AlertService {
  /**
   * Crea una nueva alerta clínica
   */
  static async createAlert(
    centerId: string,
    alertData: AlertFormData,
    createdBy: string,
    autoGenerated: boolean = false,
    sourceSessionId?: string
  ): Promise<string> {
    try {
      const alertId = await FirestoreService.createAlert(centerId, {
        ...alertData,
        autoGenerated,
        sourceSessionId,
        status: 'activa',
        notificationSent: false,
      }, createdBy);

      // Log de creación
      await this.logAlertAction(centerId, alertId, 'created', createdBy, 
        `Alerta creada: ${alertData.description}`);

      // Si es una alerta de alta urgencia, enviar notificación inmediata
      if (alertData.urgency === 'alta') {
        await this.processAlertNotification(centerId, alertId);
      }

      return alertId;
    } catch (error) {
      console.error('Error creating alert:', error);
      throw new Error('No se pudo crear la alerta');
    }
  }

  /**
   * Procesa alertas programadas que han llegado a su fecha
   */
  static async processScheduledAlerts(centerId: string): Promise<void> {
    try {
      const now = new Date();
      const alerts = await FirestoreService.getActiveAlerts(centerId);
      
      for (const alert of alerts) {
        if (alert.scheduledFor && new Date(alert.scheduledFor) <= now && !alert.notificationSent) {
          await this.processAlertNotification(centerId, alert.id);
          
          // Log de activación
          await this.logAlertAction(centerId, alert.id, 'triggered', 'system',
            `Alerta activada automáticamente en fecha programada`);
        }
      }
    } catch (error) {
      console.error('Error processing scheduled alerts:', error);
    }
  }

  /**
   * Detecta síntomas en notas de sesión usando IA
   */
  static async detectSymptomsInSession(
    centerId: string,
    sessionId: string,
    patientId: string,
    notes: string,
    professionalId: string
  ): Promise<void> {
    try {
      // Palabras clave que indican posibles alertas
      const criticalKeywords = [
        'crisis', 'suicidio', 'autolesión', 'agresión', 'violencia',
        'pánico', 'ansiedad severa', 'depresión grave', 'psicosis',
        'alucinaciones', 'delirios', 'ideación suicida'
      ];

      const notesLower = notes.toLowerCase();
      const foundKeywords = criticalKeywords.filter(keyword => 
        notesLower.includes(keyword)
      );

      if (foundKeywords.length > 0) {
        // Crear alerta automática por síntoma detectado
        await this.createAlert(centerId, {
          patientId,
          type: 'síntoma',
          description: `Síntomas detectados en sesión: ${foundKeywords.join(', ')}`,
          trigger: 'texto_IA',
          urgency: 'alta',
          notes: `Detectado automáticamente en sesión ${sessionId}`,
          notificationChannels: ['whatsapp', 'email']
        }, professionalId, true, sessionId);
      }

      // También usar análisis de IA más sofisticado
      const aiAnalysis = await AIService.analyzeSessionNotes(sessionId, notes);
      
      if (aiAnalysis.riskLevel === 'high') {
        await this.createAlert(centerId, {
          patientId,
          type: 'síntoma',
          description: `Nivel de riesgo alto detectado por IA: ${aiAnalysis.summary}`,
          trigger: 'texto_IA',
          urgency: 'alta',
          notes: `Análisis de IA - Confianza: ${(aiAnalysis.confidence * 100).toFixed(1)}%`,
          notificationChannels: ['whatsapp', 'email']
        }, professionalId, true, sessionId);
      }
    } catch (error) {
      console.error('Error detecting symptoms in session:', error);
    }
  }

  /**
   * Verifica pacientes inactivos y crea alertas
   */
  static async checkPatientInactivity(centerId: string): Promise<void> {
    try {
      const patients = await FirestoreService.getActivePatients(centerId);
      const now = new Date();
      
      for (const patient of patients) {
        const sessions = await FirestoreService.getPatientSessions(centerId, patient.id);
        
        if (sessions.length === 0) continue;
        
        const lastSession = sessions[0]; // Están ordenadas por fecha desc
        const lastSessionDate = new Date(lastSession.date);
        const daysSinceLastSession = Math.floor(
          (now.getTime() - lastSessionDate.getTime()) / (1000 * 60 * 60 * 24)
        );

        // Crear alerta si han pasado más de 30 días sin sesión
        if (daysSinceLastSession > 30) {
          // Verificar si ya existe una alerta de inactividad para este paciente
          const existingAlerts = await FirestoreService.getPatientAlerts(centerId, patient.id);
          const hasInactivityAlert = existingAlerts.some(alert => 
            alert.type === 'inactividad' && alert.status === 'activa'
          );

          if (!hasInactivityAlert) {
            await this.createAlert(centerId, {
              patientId: patient.id,
              type: 'inactividad',
              description: `Paciente sin sesiones por ${daysSinceLastSession} días`,
              trigger: 'falta_sesión',
              urgency: daysSinceLastSession > 60 ? 'alta' : 'media',
              notes: `Última sesión: ${lastSession.date}`,
              notificationChannels: ['email']
            }, patient.assignedPsychologist, true);
          }
        }
      }
    } catch (error) {
      console.error('Error checking patient inactivity:', error);
    }
  }

  /**
   * Procesa y envía notificaciones para una alerta
   */
  static async processAlertNotification(centerId: string, alertId: string): Promise<void> {
    try {
      const alert = await FirestoreService.getAlert(centerId, alertId);
      if (!alert || alert.notificationSent) return;

      const patient = await FirestoreService.getPatient(centerId, alert.patientId);
      const professional = await FirestoreService.getUser(alert.createdBy);
      
      if (!patient || !professional) return;

      let messageId: string | null = null;

      // Enviar notificación por WhatsApp si está configurado
      if (alert.notificationChannels.includes('whatsapp') && professional.phoneNumber) {
        try {
          messageId = await WhatsAppService.sendProfessionalAlert(
            professional.phoneNumber,
            ALERT_TYPE_LABELS[alert.type],
            patient.fullName,
            alert.description
          );

          await this.logAlertAction(centerId, alertId, 'notification_sent', 'system',
            `Notificación WhatsApp enviada a ${professional.phoneNumber}`);
        } catch (error) {
          await this.logAlertAction(centerId, alertId, 'notification_failed', 'system',
            `Error enviando WhatsApp: ${error.message}`);
        }
      }

      // Marcar como notificación enviada
      await FirestoreService.updateAlert(centerId, alertId, {
        notificationSent: true,
        whatsappMessageId: messageId || undefined,
        lastTriggered: new Date()
      });

    } catch (error) {
      console.error('Error processing alert notification:', error);
      await this.logAlertAction(centerId, alertId, 'notification_failed', 'system',
        `Error procesando notificación: ${error.message}`);
    }
  }

  /**
   * Resuelve una alerta
   */
  static async resolveAlert(
    centerId: string,
    alertId: string,
    resolvedBy: string,
    notes?: string
  ): Promise<void> {
    try {
      await FirestoreService.updateAlert(centerId, alertId, {
        status: 'resuelta',
        resolvedBy,
        resolvedAt: new Date(),
        notes: notes || undefined
      });

      await this.logAlertAction(centerId, alertId, 'resolved', resolvedBy,
        notes || 'Alerta marcada como resuelta');
    } catch (error) {
      console.error('Error resolving alert:', error);
      throw new Error('No se pudo resolver la alerta');
    }
  }

  /**
   * Cancela una alerta
   */
  static async cancelAlert(
    centerId: string,
    alertId: string,
    cancelledBy: string,
    reason?: string
  ): Promise<void> {
    try {
      await FirestoreService.updateAlert(centerId, alertId, {
        status: 'cancelada',
        notes: reason || undefined
      });

      await this.logAlertAction(centerId, alertId, 'cancelled', cancelledBy,
        reason || 'Alerta cancelada');
    } catch (error) {
      console.error('Error cancelling alert:', error);
      throw new Error('No se pudo cancelar la alerta');
    }
  }

  /**
   * Registra una acción en el log de alertas
   */
  private static async logAlertAction(
    centerId: string,
    alertId: string,
    action: AlertActionLog['action'],
    performedBy: string,
    details: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    try {
      await FirestoreService.createAlertLog(centerId, {
        alertId,
        action,
        performedBy,
        details,
        metadata,
        timestamp: new Date()
      });
    } catch (error) {
      console.error('Error logging alert action:', error);
    }
  }

  /**
   * Obtiene estadísticas de alertas para un centro
   */
  static async getAlertStats(centerId: string): Promise<{
    total: number;
    active: number;
    resolved: number;
    highUrgency: number;
    autoGenerated: number;
    pendingNotifications: number;
  }> {
    try {
      const alerts = await FirestoreService.getAllAlerts(centerId);
      
      return {
        total: alerts.length,
        active: alerts.filter(a => a.status === 'activa').length,
        resolved: alerts.filter(a => a.status === 'resuelta').length,
        highUrgency: alerts.filter(a => a.urgency === 'alta' && a.status === 'activa').length,
        autoGenerated: alerts.filter(a => a.autoGenerated).length,
        pendingNotifications: alerts.filter(a => !a.notificationSent && a.status === 'activa').length
      };
    } catch (error) {
      console.error('Error getting alert stats:', error);
      return {
        total: 0,
        active: 0,
        resolved: 0,
        highUrgency: 0,
        autoGenerated: 0,
        pendingNotifications: 0
      };
    }
  }
}
