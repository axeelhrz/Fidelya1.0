import { useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/context/AuthContext';
import { ClinicalAlert, AlertFilters, AlertFormData, AlertStats } from '@/types/alert';
import { FirestoreService } from '@/services/firestore';
import { AlertService } from '@/services/alertService';
import { useCollection } from './useFirestore';
import { query, where, orderBy, limit } from 'firebase/firestore';

export function useAlerts(filters?: AlertFilters) {
  const { user } = useAuth();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Construir query constraints para useCollection
  const queryConstraints = [];
  
  if (filters?.status) {
    queryConstraints.push(where('status', '==', filters.status));
  }
  
  if (filters?.type) {
    queryConstraints.push(where('type', '==', filters.type));
  }
  
  if (filters?.urgency) {
    queryConstraints.push(where('urgency', '==', filters.urgency));
  }
  
  if (filters?.patientId) {
    queryConstraints.push(where('patientId', '==', filters.patientId));
  }
  
  if (filters?.createdBy) {
    queryConstraints.push(where('createdBy', '==', filters.createdBy));
  }

  if (filters?.trigger) {
    queryConstraints.push(where('trigger', '==', filters.trigger));
  }

  queryConstraints.push(orderBy('createdAt', 'desc'));
  queryConstraints.push(limit(100)); // Limitar para performance

  const collectionPath = user?.centerId ? `centers/${user.centerId}/alerts` : '';
  
  const { 
    data: alerts, 
    loading: collectionLoading, 
    error: collectionError 
  } = useCollection<ClinicalAlert>(collectionPath, queryConstraints);

  useEffect(() => {
    setLoading(collectionLoading);
    setError(collectionError?.message || null);
  }, [collectionLoading, collectionError]);

  // Aplicar filtros del lado del cliente
  const filteredAlerts = alerts.filter(alert => {
    if (filters?.search) {
      const searchTerm = filters.search.toLowerCase();
      if (!alert.description.toLowerCase().includes(searchTerm) &&
          !alert.title.toLowerCase().includes(searchTerm) &&
          !alert.notes?.toLowerCase().includes(searchTerm)) {
        return false;
      }
    }

    if (filters?.autoGenerated !== undefined) {
      if (alert.autoGenerated !== filters.autoGenerated) {
        return false;
      }
    }

    if (filters?.dateRange) {
      const alertDate = new Date(alert.createdAt);
      if (filters.dateRange.start && alertDate < new Date(filters.dateRange.start)) {
        return false;
      }
      if (filters.dateRange.end && alertDate > new Date(filters.dateRange.end)) {
        return false;
      }
    }

    return true;
  });

  const createAlert = useCallback(async (alertData: AlertFormData) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      return await AlertService.createAlert(user.centerId, alertData, user.uid);
    } catch (error) {
      console.error('Error creating alert:', error);
      throw error;
    }
  }, [user]);

  const updateAlert = useCallback(async (alertId: string, alertData: Partial<ClinicalAlert>) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      await FirestoreService.updateAlert(user.centerId, alertId, alertData);
    } catch (error) {
      console.error('Error updating alert:', error);
      throw error;
    }
  }, [user]);

  const resolveAlert = useCallback(async (alertId: string, notes?: string) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      await AlertService.resolveAlert(user.centerId, alertId, user.uid, notes);
    } catch (error) {
      console.error('Error resolving alert:', error);
      throw error;
    }
  }, [user]);

  const cancelAlert = useCallback(async (alertId: string, reason?: string) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      await AlertService.cancelAlert(user.centerId, alertId, user.uid, reason);
    } catch (error) {
      console.error('Error cancelling alert:', error);
      throw error;
    }
  }, [user]);

  const deleteAlert = useCallback(async (alertId: string) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      await FirestoreService.deleteAlert(user.centerId, alertId);
    } catch (error) {
      console.error('Error deleting alert:', error);
      throw error;
    }
  }, [user]);

  return {
    alerts: filteredAlerts,
    loading,
    error,
    createAlert,
    updateAlert,
    resolveAlert,
    cancelAlert,
    deleteAlert,
  };
}

export function useAlertStats() {
  const { user } = useAuth();
  const [stats, setStats] = useState<AlertStats>({
    total: 0,
    active: 0,
    resolved: 0,
    cancelled: 0,
    expired: 0,
    highUrgency: 0,
    autoGenerated: 0,
    pendingNotifications: 0,
    byType: {} as Record<string, number>,
    byUrgency: {} as Record<string, number>,
    byTrigger: {} as Record<string, number>
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStats = async () => {
      if (!user?.centerId) return;
      
      try {
        setLoading(true);
        const alertStats = await AlertService.getAlertStats(user.centerId);
        setStats(alertStats);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error loading stats');
      } finally {
        setLoading(false);
      }
    };

    fetchStats();
  }, [user?.centerId]);

  return { stats, loading, error };
}

export function usePatientAlerts(patientId: string) {
  const { user } = useAuth();
  const [alerts, setAlerts] = useState<ClinicalAlert[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPatientAlerts = async () => {
      if (!user?.centerId || !patientId) return;
      
      try {
        setLoading(true);
        const patientAlerts = await FirestoreService.getPatientAlerts(user.centerId, patientId);
        setAlerts(patientAlerts);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error loading patient alerts');
      } finally {
        setLoading(false);
      }
    };

    fetchPatientAlerts();
  }, [user?.centerId, patientId]);

  return { alerts, loading, error };
}

export function useAlertAutomation() {
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);

  const triggerSymptomDetection = useCallback(async (
    sessionId: string,
    patientId: string,
    notes: string
  ) => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      setLoading(true);
      await AlertService.detectSymptomsInSession(
        user.centerId,
        sessionId,
        patientId,
        notes,
        user.uid
      );
    } catch (error) {
      console.error('Error triggering symptom detection:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [user]);

  const checkInactivity = useCallback(async () => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      setLoading(true);
      await AlertService.checkPatientInactivity(user.centerId);
    } catch (error) {
      console.error('Error checking inactivity:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [user]);

  const processScheduledAlerts = useCallback(async () => {
    if (!user?.centerId) throw new Error('No center ID available');
    
    try {
      setLoading(true);
      await AlertService.processScheduledAlerts(user.centerId);
    } catch (error) {
      console.error('Error processing scheduled alerts:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [user]);

  return {
    triggerSymptomDetection,
    checkInactivity,
    processScheduledAlerts,
    loading
  };
}

export function useRecentAlerts(limit: number = 5) {
  const { user } = useAuth();
  const [alerts, setAlerts] = useState<ClinicalAlert[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchRecentAlerts = async () => {
      if (!user?.centerId) return;
      
      try {
        setLoading(true);
        const recentAlerts = await FirestoreService.getRecentAlerts(user.centerId, limit);
        setAlerts(recentAlerts);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error loading recent alerts');
      } finally {
        setLoading(false);
      }
    };

    fetchRecentAlerts();
  }, [user?.centerId, limit]);

  return { alerts, loading, error };
}